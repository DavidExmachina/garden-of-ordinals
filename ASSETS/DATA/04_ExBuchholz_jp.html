<!DOCTYPE html>
<html>
    <head></head>
    <body>
        <h1>定義</h1><hr>
        <p>&emsp;&emsp;拡張ブーフホルツの\( \psi \)関数とはDenis Maksudovが2017年に提案したブーフホルツの\( \psi \)関数の拡張である<sup><a id="g1" href="#c1">[1]</a></sup>。関数\( \psi_\alpha(\beta) \)はこのように定義されます：</p>
        <p>&emsp;&emsp;\( \begin{align} C_0(\alpha,\beta) := & \begin{cases} 1 & \alpha=0 \\ \Omega_\alpha & \alpha&gt;0 \end{cases} \\ C_{n+1}(\alpha,\beta) := & \{\gamma|\gamma=\gamma_0+\gamma_1\land\gamma_0,\gamma_1\in C_n(\alpha,\beta)\} \\ \cup & \{\gamma|\gamma=\psi_{\alpha'}(\beta')\land\alpha'\in C_n(\alpha,\beta)\land\beta'\in C_n(\alpha,\beta)\land\beta'&lt;\beta\} \\ C(\alpha,\beta) := & \bigcup_{n&lt;\omega}{C_n(\alpha,\beta)}=C_0(\alpha,\beta)\cup C_1(\alpha,\beta)\cup C_2(\alpha,\beta)\cup\cdots\cup C_m(\alpha,\beta)\cup\cdots \\ \psi_\alpha(\beta) := & min(Ord\setminus C(\alpha,\beta)) \end{align} \)</p>
        <br>
        <p>&emsp;&emsp;元のブーフホルツの\( \psi \)関数との唯一の違いは、\( C_{n+1}(\alpha,\beta) \)の定義では、元の\( \alpha'&lt;\omega+1 \)が\( \alpha'\in C_n(\alpha,\beta) \)に変更されています。これにより、この関数は\( \Omega_\omega \)より大きく\( \Omega_{\Omega_{\Omega_{\cdot_{\cdot_\cdot}}}} \)、\( \Omega \)不動点より小さい非可算基数を使用できるようになります。</p>
        <p>&emsp;&emsp;このサイトで使用されている基本列システムは以下のように定義されます、すべての項は標準形である必要があることに注意してください。複雑さのため、標準形は「順序数表記」部分で定義されます：</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">01.</span> \( \alpha=0 \)ならば、\( \alpha[n]:=0 \)及び\( Cof(\alpha):=0 \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">02.</span> \( \alpha=\psi_{\beta_1}(\gamma_1)+\psi_{\beta_2}(\gamma_2)+\cdots+\psi_{\beta_m}(\gamma_m) \)及び\( m&gt;1 \)ならば：</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">02.01.</span> \( \alpha[n]:=\psi_{\beta_1}(\gamma_1)+\psi_{\beta_2}(\gamma_2)+\cdots+\psi_{\beta_m}(\gamma_m)[n] \)及び\( Cof(\alpha):=Cof(\psi_{\beta_m}(\gamma_m)) \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.</span> \( \alpha=\psi_0(0)=1 \)ならば、\( \alpha[n]:=0 \)及び\( Cof(\alpha):=1 \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">04.</span> \( \alpha=\psi_{\beta}(0)=\Omega_\beta \)及び\( Cof(\beta)=1 \)ならば、\( \alpha[n]:=n \)及び\( Cof(\alpha):=\alpha \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">05.</span> \( \alpha=\psi_{\beta}(0)=\Omega_\beta \)及び\( Cof(\beta)&gt;1 \)ならば、\( \alpha[n]:=\psi_{\beta[n]}(0) \)及び\( Cof(\alpha):=Cof(\beta) \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">06.</span> \( \alpha=\psi_{\beta}(\gamma) \)及び\( Cof(\gamma)=1 \)ならば、\( \alpha[n]:=\psi_{\beta}(\gamma[0])*n \)及び\( Cof(\alpha):=\psi_0(\psi_0(0))=\omega \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">07.</span> \( \alpha=\psi_{\beta}(\gamma) \)及び\( 1&lt;Cof(\gamma)\le\Omega_\beta \)ならば、\( \alpha[n]:=\psi_{\beta}(\gamma[n]) \)及び\( Cof(\alpha):=Cof(\gamma) \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">08.</span> \( \alpha=\psi_{\beta}(\gamma) \)及び\( \Omega_\beta&lt;Cof(\gamma) \)ならば、\( \alpha[0]:=0 \)及び\( \alpha[n+1]:=\psi_{\beta}(Re(\gamma,n)) \)及び\( Cof(\alpha):=\omega \)、</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">08.01.</span> ここで\( Re(\gamma,0):=\gamma[0] \)及び\( Re(\gamma,n+1):=\gamma[\psi_{\delta}(Re(\gamma,n))] \)及び\( \Omega_{\delta+1}=Cof(\gamma) \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">09.</span> \( \alpha=\Omega_{\Omega_{\Omega_{\cdot_{\cdot_\cdot}}}} \)ならば、\( \alpha[0]:=0 \)及び\( \alpha[n+1]:=\psi_{\alpha[n]}(0) \)及び\( Cof(\alpha):=\omega \)</p>
        <br>
        <p>&emsp;&emsp;ちなみに、Denis Maksudovもサイトで基本列システムを定義した、上記の定義とは少し異なります。</p>
        <p>&emsp;&emsp;この順序数崩壊関数の可算限界は\( \psi_0(\Omega_{\Omega_{\Omega_{\cdot_{\cdot_\cdot}}}}) \)と表記され、「大ホルツ順序数（LBO）」と呼ばれ、「拡張ブーフホルツ順序数（EBO）」とも呼ばれます。これは\( \Pi_1^1-TR_0 \)の証明論的順序数である<sup><a id="g2" href="#c2">[2]</a></sup>。</p>
        <h1>順序数表記</h1><hr>
        <h2>表記</h2><hr>
        <p>&emsp;&emsp;\( S \)を以下の文字を含む集合として定義します：</p>
        <p>&emsp;&emsp;定数「\( \overline{0} \)」、</p>
        <p>&emsp;&emsp;関数文字「\( \psi \)」、</p>
        <p>&emsp;&emsp;そして他の文字「\( + \)」、「\( ( \)」、「\( ) \)」と「\( , \)」。</p>
        <br>
        <p>&emsp;&emsp;\( S \)部分集合、\( T_m \)と\( T_s \)を以下のように定義します：</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">01.</span> \( \overline{0}\in T_m \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">02.</span> 任意の\( a\in T_s \)と\( b\in T_m\setminus\{\overline{0}\} \)に対して、\( a+b\in T_m \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.</span> 任意の\( a,b\in T_m \)に対して、\( \psi(a,b)\in T_m \)及び\( \psi(a,b)\in T_s \)</p>
        <br>
        <p>&emsp;&emsp;この記事では、以下の略記を使用します：</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">01.</span> \( \psi_a(b):=\psi(a,b) \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">02.</span> \( \overline{1}:=\psi_\overline{0}(\overline{0}) \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.</span> \( \overline{\omega}:=\psi_\overline{0}(\overline{1}) \)</p>
        <h2>順序</h2><hr>
        <p>&emsp;&emsp;二項関係\( &lt; \)を以下のように定義します：</p>
        <p>&emsp;&emsp;\( (a\in T_m,b\in T_m)\mapsto a&lt;b\in\{\mathbb{T},\mathbb{F}\} \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">01.</span> \( b=\overline{0} \)ならば、\( \mathbb{F} \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">02.</span> \( a=\overline{0}\land b\neq\overline{0} \)ならば、\( \mathbb{T} \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.</span> \( a=a_0+a_1\land b=b_0+b_1\land a_0,b_0\in T_s\land a_1,b_1\in T_m\setminus\{\overline{0}\} \)ならば：</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.01.</span> \( a_0&lt;b_0 \)ならば、\( \mathbb{T} \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.02.</span> \( \neg a_0&lt;b_0 \)ならば、\( \neg b_0&lt;a_0\land a_1&lt;b_1 \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">04.</span> \( a=a_0+a_1\land b,a_0\in T_s\land a_1\in T_m\setminus\{\overline{0}\} \)ならば、\( a_0&lt;b \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">05.</span> \( b=b_0+b_1\land a,b_0\in T_s\land b_1\in T_m\setminus\{\overline{0}\} \)ならば、\( \neg b_0&lt;a \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">06.</span> \( a=\psi_{a_0}(a_1)\land b=\psi_{b_0}(b_1)\land a_0,a_1,b_0,b_1\in T_m \)ならば、\( a_0&lt;b_0\vee(\neg b_0&lt;a_0\land a_1&lt;b_1) \)を返す</p>
        <br>
        <p>&emsp;&emsp;他のすべての比較演算子を定義します：</p>
        <p>&emsp;&emsp;\( (a\in T_m,b\in T_m)\mapsto a&gt;b\in\{\mathbb{T},\mathbb{F}\} \)</p>
        <p>&emsp;&emsp;\( b&lt;a \)を返す</p>
        <br>
        <p>&emsp;&emsp;\( (a\in T_m,b\in T_m)\mapsto a\le b\in\{\mathbb{T},\mathbb{F}\} \)</p>
        <p>&emsp;&emsp;\( \neg b&lt;a \)を返す</p>
        <br>
        <p>&emsp;&emsp;\( (a\in T_m,b\in T_m)\mapsto a\ge b\in\{\mathbb{T},\mathbb{F}\} \)</p>
        <p>&emsp;&emsp;\( \neg a&lt;b \)を返す</p>
        <br>
        <p>&emsp;&emsp;\( (a\in T_m,b\in T_m)\mapsto a=_*b\in\{\mathbb{T},\mathbb{F}\} \)</p>
        <p>&emsp;&emsp;\( \neg a&lt;b\land\neg b&lt;a \)を返す</p>
        <br>
        <p>&emsp;&emsp;\( (a\in T_m,b\in T_m)\mapsto a\neq_*b\in\{\mathbb{T},\mathbb{F}\} \)</p>
        <p>&emsp;&emsp;\( a&lt;b\vee b&lt;a \)を返す</p>
        <br>
        <p>&emsp;&emsp;\( = \)と\( \neq \)は記号的な等価性を表し、\( =_* \)と\( \neq_* \)は数値的な等価性を表すことに注意してください。</p>
        <h2>標準形</h2><hr>
        <p>&emsp;&emsp;順序数\( c \)が\( C(a,b) \)の元であるかどうかを判断するため、関数\( \in C \)を以下のように定義します：</p>
        <p>&emsp;&emsp;\( (c\in T_m,a\in T_m,b\in T_m)\mapsto c\in C(a,b)\in\{\mathbb{T},\mathbb{F}\} \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">01.</span> \( c&lt;\psi_a(\overline{0}) \)ならば、\( \mathbb{T} \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">02.</span> \( \neg c&lt;\psi_a(\overline{0}) \)ならば：</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">02.01.</span> \( c=c_0+c_1\land c_0\in T_s\land c_1\in T_m\setminus\{\overline{0}\} \)ならば、\( c_0\in C(a,b)\land c_1\in C(a,b) \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">02.02.</span> \( c=\psi_{c_0}(c_1)\land c_0,c_1\in T_m \)ならば、\( c_0\in C(a,b)\land c_1\in C(a,b)\land c_1&lt;b \)を返す</p>
        <br>
        <p>&emsp;&emsp;順序数が標準形であるかどうかを判断するため、関数\( \in T \)を以下のように定義します：</p>
        <p>&emsp;&emsp;\( (a\in T_m)\mapsto (a\in T)\in\{\mathbb{T},\mathbb{F}\} \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">01.</span> \( a=\overline{0} \)ならば、\( \mathbb{T} \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">02.</span> \( a=a_0+a_1\land a_0\in T_s\land a_1\in T_m\setminus\{\overline{0}\} \)ならば：</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">02.01.</span> \( \neg a_0\in T\vee\neg a_1\in T \)ならば、\( \mathbb{F} \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">02.02.</span> \( a_0\in T\land a_1\in T \)ならば：</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">02.02.01.</span> \( a_1\in T_s \)ならば、\( \neg a_0&lt;a_1 \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">02.02.02.</span> \( a_1=a_2+a_3\land a_2\in T_s\land a_3\in T_m\setminus\{\overline{0}\} \)ならば、\( \neg a_0&lt;a_2 \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.</span> \( a=\psi_{a_0}(a_1)\land a_0,a_1\in T_m \)ならば、\( a_0\in T\land a_1\in T\land a_1\in C(a_0,a_1) \)を返す</p>
        <br>
        <p>&emsp;&emsp;このシステムの限界を\( A=\Omega_{\Omega_{\Omega_{\cdot_{\cdot_\cdot}}}} \)と定義します。</p>
        <p>&emsp;&emsp;\( \Omega_{\Omega_{\Omega_{\cdot_{\cdot_\cdot}}}} \)も標準形である。</p>
        <p>&emsp;&emsp;このシステムのすべての順序数に対して、\( \alpha&lt;\Omega_{\Omega_{\Omega_{\cdot_{\cdot_\cdot}}}} \)。</p>
        <p>&emsp;&emsp;\( \alpha&lt;\psi_\overline{1}(\overline{0}) \)の場合に限り、順序数\( \alpha \)は可算である。</p>
        <p>&emsp;&emsp;コマンド「fgh」と「sgh」の専用の可算順序数限界は\( \psi_\overline{0}(\Omega_{\Omega_{\Omega_{\cdot_{\cdot_\cdot}}}}) \)である。そのコンピューターコードは(,A)である。</p>
        <h2>演算</h2><hr>
        <p>&emsp;&emsp;加法\( Add \)を以下のように定義します：</p>
        <p>&emsp;&emsp;\( (a\in T,b\in T)\mapsto Add(a,b)\in T \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">01.</span> \( a=\overline{0} \)ならば、\( b \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">02.</span> \( a\neq\overline{0}\land b=\overline{0} \)ならば、\( a \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.</span> \( a\neq\overline{0}\land b\neq\overline{0} \)ならば、\( a+b \)を返す</p>
        <h2>共終数</h2><hr>
        <p>&emsp;&emsp;共終数関数\( Cof \)を以下のように定義します：</p>
        <p>&emsp;&emsp;\( (a\in T)\mapsto Cof(a)\in T \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">01.</span> \( a=\overline{0} \)ならば、\( a \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">02.</span> \( a=a_0+a_1\land a_0\in T_s\land a_1\in T_m\setminus\{\overline{0}\} \)ならば、\( Cof(a_1) \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.</span> \( a=\psi_{a_0}(a_1)\land a_0,a_1\in T_m \)ならば：</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.01.</span> \( a_1=\overline{0} \)ならば：</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.01.01.</span> \( Cof(a_0)&lt;\overline{\omega} \)ならば、\( a \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.01.02.</span> \( \neg Cof(a_0)&lt;\overline{\omega} \)ならば、\( Cof(a_0) \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.02.</span> \( Cof(a_1)=\overline{1} \)ならば、\( \overline{\omega} \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.03.</span> \( \neg Cof(a_1)&lt;\overline{\omega} \)ならば：</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.03.01.</span> \( \neg\psi_{a_0}(0)&lt;Cof(a_1) \)ならば、\( Cof(a_1) \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.03.02.</span> \( \psi_{a_0}(0)&lt;Cof(a_1) \)ならば、\( \overline{\omega} \)を返す</p>
        <br>
        <p>&emsp;&emsp;また、\( Cof(\Omega_{\Omega_{\Omega_{\cdot_{\cdot_\cdot}}}})=\overline{\omega} \)と定義します。</p>
        <h2>基本列</h2><hr>
        <p>&emsp;&emsp;基本列\( [] \)を以下のように定義します：</p>
        <p>&emsp;&emsp;\( (a\in T,n\in T)\mapsto a[n]\in T \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">01.</span> \( a=\overline{0} \)ならば、\( \overline{0} \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">02.</span> \( a=a_0+a_1\land a_0\in T_s\land a_1\in T_m\setminus\{\overline{0}\} \)ならば、\( Add(a_0,a_1[n]) \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.</span> \( a=\psi_{a_0}(a_1)\land a_0,a_1\in T_m \)ならば：</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.01.</span> \( a_1=\overline{0} \)ならば：</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.01.01.</span> \( a_0=\overline{0} \)ならば、\( \overline{0} \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.01.02.</span> \( Cof(a_0)=\overline{1} \)ならば、\( n \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.01.03.</span> \( \neg Cof(a_0)&lt;\overline{\omega} \)ならば、\( \psi_{a_0[n]}(\overline{0}) \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.02.</span> \( Cof(a_1)=\overline{1} \)ならば：</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.02.01.</span> \( n=\overline{0} \)ならば、\( \overline{0} \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.02.02.</span> \( n\neq\overline{0} \)ならば、\( Add(a[n[\overline{0}]], \psi_{a_0}(a_1[\overline{0}])) \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.03.</span> \( \neg Cof(a_1)&lt;\overline{\omega} \)ならば：</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.03.01.</span> \( \neg\psi_{a_0}(0)&lt;Cof(a_1) \)ならば、\( \psi_{a_0}(a_1[n]) \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.03.02.</span> \( \psi_{a_0}(0)&lt;Cof(a_1) \)ならば：</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.03.02.01.</span> \( n=\overline{0} \)ならば、\( \overline{0} \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">03.03.02.02.</span> \( n\neq\overline{0} \)ならば、\( \psi_{a_0}(Re(a_1,n[\overline{0}])) \)を返す</p>
        <br>
        <p>&emsp;&emsp;反復関数\( Re \)を以下のように定義します：</p>
        <p>&emsp;&emsp;\( (a\in T,n\in T)\mapsto Re(a,n)\in T \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">01.</span> \( n=\overline{0} \)ならば、\( a[\overline{0}] \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">02.</span> \( n\neq\overline{0}\land Cof(a)=\psi_{a_0}(0)\land a_1=a_0[\overline{0}] \)ならば、\( a[\psi_{a_1}(Re(a,n[\overline{0}]))] \)を返す</p>
        <br>
        <p>&emsp;&emsp;共終数は非可算の順序数をより小さい共終数は可算の順序数として展開するため、強基本列\( {[]}^* \)を以下のように定義します：</p>
        <p>&emsp;&emsp;\( (a\in T,n\in T)\mapsto a{[n]}^*\in T \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">01.</span> \( \neg\overline{\omega}&lt;Cof(a) \)ならば、\( a[n] \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">02.</span> \( \overline{\omega}&lt;Cof(a)\land Cof(a)=\psi_{a_0}(0)\land a_1=a_0[\overline{0}] \)ならば、\( a[\psi_{a_1}(\Omega_{\Omega_{\Omega_{\cdot_{\cdot_\cdot}}}}[n])] \)を返す</p>
        <br>
        <p>&emsp;&emsp;また、\( \Omega_{\Omega_{\Omega_{\cdot_{\cdot_\cdot}}}} \)的基本列を以下のように定義します：</p>
        <p>&emsp;&emsp;\( (n\in T)\mapsto\Omega_{\Omega_{\Omega_{\cdot_{\cdot_\cdot}}}}[n]\in T \)</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">01.</span> \( n=\overline{0} \)ならば、\( \overline{0} \)を返す</p>
        <p>&emsp;&emsp;<span style="opacity: 0.5;">02.</span> \( n\neq\overline{0} \)ならば、\( \psi_{\Omega_{\Omega_{\Omega_{\cdot_{\cdot_\cdot}}}}[n[\overline{0}]]}(\overline{0}) \)を返す</p>
        <h1>出典</h1><hr>
        <p>&emsp;&emsp;<a id="c1" href="#g1">[1]</a>Denis Maksudov. <a href="https://sites.google.com/site/travelingtotheinfinity/the-extension-of-buchholz-s-function" target="_blank">The extended Wilfried Buchholz's functions.</a> Traveling To The Infinity. Retrieved 2024-12-13.</p>
        <p>&emsp;&emsp;<a id="c2" href="#g2">[2]</a>Rathjen, M. (2010). <a href="https://web.archive.org/web/20231207051455/https://www1.maths.leeds.ac.uk/~rathjen/Dissertation_Ontos.pdf" target="_blank">Investigations of Subsystems of Second Order Arithmetic and Set Theory in Strength between \( \Pi_1^1-CA \) and \( \Delta_2^1-CA+BI \): Part I.</a> In R. Schindler (Ed.), Ways of Proof Theory (pp. 363-440). Berlin, Boston: De Gruyter. Retrieved 2024-12-13. https://doi.org/10.1515/9783110324907.363</p>
    </body>
</html>